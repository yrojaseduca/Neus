{"ast":null,"code":"import _toConsumableArray from \"/Applications/XAMPP/xamppfiles/htdocs/neus/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/neus/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Applications/XAMPP/xamppfiles/htdocs/neus/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n// Composables\nimport { useProxiedModel } from \"../../../composables/proxiedModel.mjs\"; // Utilities\nimport { computed, inject, provide, ref } from 'vue';\nimport { getObjectValueByPath, propsFactory } from \"../../../util/index.mjs\"; // Types\nexport var makeDataTableGroupProps = propsFactory({\n  groupBy: {\n    type: Array,\n    \"default\": function _default() {\n      return [];\n    }\n  }\n}, 'DataTable-group');\nvar VDataTableGroupSymbol = Symbol[\"for\"]('vuetify:data-table-group');\nexport function createGroupBy(props) {\n  var groupBy = useProxiedModel(props, 'groupBy');\n  return {\n    groupBy: groupBy\n  };\n}\nexport function provideGroupBy(options) {\n  var groupBy = options.groupBy,\n    sortBy = options.sortBy;\n  var opened = ref(new Set());\n  var sortByWithGroups = computed(function () {\n    return groupBy.value.map(function (val) {\n      var _val$order;\n      return _objectSpread(_objectSpread({}, val), {}, {\n        order: (_val$order = val.order) !== null && _val$order !== void 0 ? _val$order : false\n      });\n    }).concat(sortBy.value);\n  });\n  function isGroupOpen(group) {\n    return opened.value.has(group.id);\n  }\n  function toggleGroup(group) {\n    var newOpened = new Set(opened.value);\n    if (!isGroupOpen(group)) newOpened.add(group.id);else newOpened[\"delete\"](group.id);\n    opened.value = newOpened;\n  }\n  function extractRows(items) {\n    function dive(group) {\n      var arr = [];\n      var _iterator = _createForOfIteratorHelper(group.items),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          if ('type' in item && item.type === 'group') {\n            arr.push.apply(arr, _toConsumableArray(dive(item)));\n          } else {\n            arr.push(item);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return arr;\n    }\n    return dive({\n      type: 'group',\n      items: items,\n      id: 'dummy',\n      key: 'dummy',\n      value: 'dummy',\n      depth: 0\n    });\n  }\n\n  // onBeforeMount(() => {\n  //   for (const key of groupedItems.value.keys()) {\n  //     opened.value.add(key)\n  //   }\n  // })\n\n  var data = {\n    sortByWithGroups: sortByWithGroups,\n    toggleGroup: toggleGroup,\n    opened: opened,\n    groupBy: groupBy,\n    extractRows: extractRows,\n    isGroupOpen: isGroupOpen\n  };\n  provide(VDataTableGroupSymbol, data);\n  return data;\n}\nexport function useGroupBy() {\n  var data = inject(VDataTableGroupSymbol);\n  if (!data) throw new Error('Missing group!');\n  return data;\n}\nfunction groupItemsByProperty(items, groupBy) {\n  if (!items.length) return [];\n  var groups = new Map();\n  var _iterator2 = _createForOfIteratorHelper(items),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      var value = getObjectValueByPath(item.raw, groupBy);\n      if (!groups.has(value)) {\n        groups.set(value, []);\n      }\n      groups.get(value).push(item);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return groups;\n}\nfunction groupItems(items, groupBy) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'root';\n  if (!groupBy.length) return [];\n  var groupedItems = groupItemsByProperty(items, groupBy[0]);\n  var groups = [];\n  var rest = groupBy.slice(1);\n  groupedItems.forEach(function (items, value) {\n    var key = groupBy[0];\n    var id = \"\".concat(prefix, \"_\").concat(key, \"_\").concat(value);\n    groups.push({\n      depth: depth,\n      id: id,\n      key: key,\n      value: value,\n      items: rest.length ? groupItems(items, rest, depth + 1, id) : items,\n      type: 'group'\n    });\n  });\n  return groups;\n}\nfunction flattenItems(items, opened) {\n  var flatItems = [];\n  var _iterator3 = _createForOfIteratorHelper(items),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      // TODO: make this better\n      if ('type' in item && item.type === 'group') {\n        if (item.value != null) {\n          flatItems.push(item);\n        }\n        if (opened.has(item.id) || item.value == null) {\n          flatItems.push.apply(flatItems, _toConsumableArray(flattenItems(item.items, opened)));\n        }\n      } else {\n        flatItems.push(item);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return flatItems;\n}\nexport function useGroupedItems(items, groupBy, opened) {\n  var flatItems = computed(function () {\n    if (!groupBy.value.length) return items.value;\n    var groupedItems = groupItems(items.value, groupBy.value.map(function (item) {\n      return item.key;\n    }));\n    return flattenItems(groupedItems, opened.value);\n  });\n  return {\n    flatItems: flatItems\n  };\n}","map":{"version":3,"names":["useProxiedModel","computed","inject","provide","ref","getObjectValueByPath","propsFactory","makeDataTableGroupProps","groupBy","type","Array","_default","VDataTableGroupSymbol","Symbol","createGroupBy","props","provideGroupBy","options","sortBy","opened","Set","sortByWithGroups","value","map","val","_val$order","_objectSpread","order","concat","isGroupOpen","group","has","id","toggleGroup","newOpened","add","extractRows","items","dive","arr","_iterator","_createForOfIteratorHelper","_step","s","n","done","item","push","apply","_toConsumableArray","err","e","f","key","depth","data","useGroupBy","Error","groupItemsByProperty","length","groups","Map","_iterator2","_step2","raw","set","get","groupItems","arguments","undefined","prefix","groupedItems","rest","slice","forEach","flattenItems","flatItems","_iterator3","_step3","useGroupedItems"],"sources":["../../../../src/components/VDataTable/composables/group.ts"],"sourcesContent":["// Composables\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utilities\nimport { computed, inject, provide, ref } from 'vue'\nimport { getObjectValueByPath, propsFactory } from '@/util'\n\n// Types\nimport type { InjectionKey, PropType, Ref } from 'vue'\nimport type { SortItem } from './sort'\nimport type { DataTableItem } from '../types'\n\nexport interface GroupableItem<T = any> {\n  type: 'item'\n  raw: T\n}\n\nexport interface Group<T = any> {\n  type: 'group'\n  depth: number\n  id: string\n  key: string\n  value: any\n  items: readonly (T | Group<T>)[]\n}\n\nexport const makeDataTableGroupProps = propsFactory({\n  groupBy: {\n    type: Array as PropType<readonly SortItem[]>,\n    default: () => ([]),\n  },\n}, 'DataTable-group')\n\nconst VDataTableGroupSymbol: InjectionKey<{\n  opened: Ref<Set<string>>\n  toggleGroup: (group: Group) => void\n  isGroupOpen: (group: Group) => boolean\n  sortByWithGroups: Ref<SortItem[]>\n  groupBy: Ref<readonly SortItem[]>\n  extractRows: (items: (DataTableItem | Group<DataTableItem>)[]) => DataTableItem[]\n}> = Symbol.for('vuetify:data-table-group')\n\ntype GroupProps = {\n  groupBy: readonly SortItem[]\n  'onUpdate:groupBy': ((value: SortItem[]) => void) | undefined\n}\n\nexport function createGroupBy (props: GroupProps) {\n  const groupBy = useProxiedModel(props, 'groupBy')\n\n  return { groupBy }\n}\n\nexport function provideGroupBy (options: { groupBy: Ref<readonly SortItem[]>, sortBy: Ref<readonly SortItem[]> }) {\n  const { groupBy, sortBy } = options\n  const opened = ref(new Set<string>())\n\n  const sortByWithGroups = computed(() => {\n    return groupBy.value.map<SortItem>(val => ({\n      ...val,\n      order: val.order ?? false,\n    })).concat(sortBy.value)\n  })\n\n  function isGroupOpen (group: Group) {\n    return opened.value.has(group.id)\n  }\n\n  function toggleGroup (group: Group) {\n    const newOpened = new Set(opened.value)\n    if (!isGroupOpen(group)) newOpened.add(group.id)\n    else newOpened.delete(group.id)\n\n    opened.value = newOpened\n  }\n\n  function extractRows <T extends GroupableItem> (items: readonly (T | Group<T>)[]) {\n    function dive (group: Group<T>): T[] {\n      const arr = []\n\n      for (const item of group.items) {\n        if ('type' in item && item.type === 'group') {\n          arr.push(...dive(item))\n        } else {\n          arr.push(item as T)\n        }\n      }\n\n      return arr\n    }\n    return dive({ type: 'group', items, id: 'dummy', key: 'dummy', value: 'dummy', depth: 0 })\n  }\n\n  // onBeforeMount(() => {\n  //   for (const key of groupedItems.value.keys()) {\n  //     opened.value.add(key)\n  //   }\n  // })\n\n  const data = { sortByWithGroups, toggleGroup, opened, groupBy, extractRows, isGroupOpen }\n\n  provide(VDataTableGroupSymbol, data)\n\n  return data\n}\n\nexport function useGroupBy () {\n  const data = inject(VDataTableGroupSymbol)\n\n  if (!data) throw new Error('Missing group!')\n\n  return data\n}\n\nfunction groupItemsByProperty <T extends GroupableItem> (items: readonly T[], groupBy: string) {\n  if (!items.length) return []\n\n  const groups = new Map<any, T[]>()\n  for (const item of items) {\n    const value = getObjectValueByPath(item.raw, groupBy)\n\n    if (!groups.has(value)) {\n      groups.set(value, [])\n    }\n    groups.get(value)!.push(item)\n  }\n\n  return groups\n}\n\nfunction groupItems <T extends GroupableItem> (items: readonly T[], groupBy: readonly string[], depth = 0, prefix = 'root') {\n  if (!groupBy.length) return []\n\n  const groupedItems = groupItemsByProperty(items, groupBy[0])\n  const groups: Group<T>[] = []\n\n  const rest = groupBy.slice(1)\n  groupedItems.forEach((items, value) => {\n    const key = groupBy[0]\n    const id = `${prefix}_${key}_${value}`\n    groups.push({\n      depth,\n      id,\n      key,\n      value,\n      items: rest.length ? groupItems(items, rest, depth + 1, id) : items,\n      type: 'group',\n    })\n  })\n\n  return groups\n}\n\nfunction flattenItems <T extends GroupableItem> (items: readonly (T | Group<T>)[], opened: Set<string>): readonly (T | Group<T>)[] {\n  const flatItems: (T | Group<T>)[] = []\n\n  for (const item of items) {\n    // TODO: make this better\n    if ('type' in item && item.type === 'group') {\n      if (item.value != null) {\n        flatItems.push(item)\n      }\n\n      if (opened.has(item.id) || item.value == null) {\n        flatItems.push(...flattenItems(item.items, opened))\n      }\n    } else {\n      flatItems.push(item)\n    }\n  }\n\n  return flatItems\n}\n\nexport function useGroupedItems <T extends GroupableItem> (\n  items: Ref<T[]>,\n  groupBy: Ref<readonly SortItem[]>,\n  opened: Ref<Set<string>>\n) {\n  const flatItems = computed(() => {\n    if (!groupBy.value.length) return items.value\n\n    const groupedItems = groupItems(items.value, groupBy.value.map(item => item.key))\n\n    return flattenItems(groupedItems, opened.value)\n  })\n\n  return { flatItems }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}