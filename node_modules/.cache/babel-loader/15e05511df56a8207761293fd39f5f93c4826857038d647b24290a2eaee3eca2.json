{"ast":null,"code":"import _toConsumableArray from \"/Applications/XAMPP/xamppfiles/htdocs/neus/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/neus/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Applications/XAMPP/xamppfiles/htdocs/neus/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.fixed.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.array.flat.js\";\nimport \"core-js/modules/es.array.unscopables.flat.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\n// Utilities\nimport { capitalize, inject, provide, ref, watchEffect } from 'vue';\nimport { consoleError, propsFactory } from \"../../../util/index.mjs\"; // Types\nexport var makeDataTableHeaderProps = propsFactory({\n  headers: Array\n}, 'DataTable-header');\nexport var VDataTableHeadersSymbol = Symbol[\"for\"]('vuetify:data-table-headers');\nvar defaultHeader = {\n  title: '',\n  sortable: false\n};\nvar defaultActionHeader = _objectSpread(_objectSpread({}, defaultHeader), {}, {\n  width: 48\n});\nfunction priorityQueue() {\n  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var queue = arr.map(function (element) {\n    return {\n      element: element,\n      priority: 0\n    };\n  });\n  return {\n    enqueue: function enqueue(element, priority) {\n      var added = false;\n      for (var i = 0; i < queue.length; i++) {\n        var item = queue[i];\n        if (item.priority > priority) {\n          queue.splice(i, 0, {\n            element: element,\n            priority: priority\n          });\n          added = true;\n          break;\n        }\n      }\n      if (!added) queue.push({\n        element: element,\n        priority: priority\n      });\n    },\n    size: function size() {\n      return queue.length;\n    },\n    count: function count() {\n      var count = 0;\n      if (!queue.length) return 0;\n      var whole = Math.floor(queue[0].priority);\n      for (var i = 0; i < queue.length; i++) {\n        if (Math.floor(queue[i].priority) === whole) count += 1;\n      }\n      return count;\n    },\n    dequeue: function dequeue() {\n      return queue.shift();\n    }\n  };\n}\nfunction extractLeaves(item) {\n  var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (!item.children) {\n    columns.push(item);\n  } else {\n    var _iterator = _createForOfIteratorHelper(item.children),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var child = _step.value;\n        extractLeaves(child, columns);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return columns;\n}\nfunction extractKeys(headers) {\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  var _iterator2 = _createForOfIteratorHelper(headers),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      if (item.key) keys.add(item.key);\n      if (item.children) {\n        extractKeys(item.children, keys);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return keys;\n}\nfunction getDefaultItem(item) {\n  if (!item.key) return undefined;\n  if (item.key === 'data-table-group') return defaultHeader;\n  if (['data-table-expand', 'data-table-select'].includes(item.key)) return defaultActionHeader;\n  return undefined;\n}\nfunction getDepth(item) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!item.children) return depth;\n  return Math.max.apply(Math, [depth].concat(_toConsumableArray(item.children.map(function (child) {\n    return getDepth(child, depth + 1);\n  }))));\n}\nfunction parseFixedColumns(items) {\n  var seenFixed = false;\n  function setFixed(item) {\n    var parentFixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!item) return;\n    if (parentFixed) {\n      item.fixed = true;\n    }\n    if (item.fixed) {\n      if (item.children) {\n        for (var i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i], true);\n        }\n      } else {\n        if (!seenFixed) {\n          item.lastFixed = true;\n        } else if (isNaN(+item.width)) {\n          consoleError(\"Multiple fixed columns should have a static width (key: \".concat(item.key, \")\"));\n        }\n        seenFixed = true;\n      }\n    } else {\n      if (item.children) {\n        for (var _i = item.children.length - 1; _i >= 0; _i--) {\n          setFixed(item.children[_i]);\n        }\n      } else {\n        seenFixed = false;\n      }\n    }\n  }\n  for (var i = items.length - 1; i >= 0; i--) {\n    setFixed(items[i]);\n  }\n  function setFixedOffset(item) {\n    var fixedOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (!item) return fixedOffset;\n    if (item.children) {\n      item.fixedOffset = fixedOffset;\n      var _iterator3 = _createForOfIteratorHelper(item.children),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          fixedOffset = setFixedOffset(child, fixedOffset);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    } else if (item.fixed) {\n      item.fixedOffset = fixedOffset;\n      fixedOffset += parseFloat(item.width || '0') || 0;\n    }\n    return fixedOffset;\n  }\n  var fixedOffset = 0;\n  var _iterator4 = _createForOfIteratorHelper(items),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var item = _step4.value;\n      fixedOffset = setFixedOffset(item, fixedOffset);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\nfunction parse(items, maxDepth) {\n  var headers = [];\n  var currentDepth = 0;\n  var queue = priorityQueue(items);\n  while (queue.size() > 0) {\n    var rowSize = queue.count();\n    var row = [];\n    var fraction = 1;\n    while (rowSize > 0) {\n      var _queue$dequeue = queue.dequeue(),\n        item = _queue$dequeue.element,\n        priority = _queue$dequeue.priority;\n      var diff = maxDepth - currentDepth - getDepth(item);\n      row.push(_objectSpread(_objectSpread({}, item), {}, {\n        rowspan: diff !== null && diff !== void 0 ? diff : 1,\n        colspan: item.children ? extractLeaves(item).length : 1\n      }));\n      if (item.children) {\n        var _iterator5 = _createForOfIteratorHelper(item.children),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var child = _step5.value;\n            // This internally sorts items that are on the same priority \"row\"\n            var sort = priority % 1 + fraction / Math.pow(10, currentDepth + 2);\n            queue.enqueue(child, currentDepth + diff + sort);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n      fraction += 1;\n      rowSize -= 1;\n    }\n    currentDepth += 1;\n    headers.push(row);\n  }\n  var columns = items.map(function (item) {\n    return extractLeaves(item);\n  }).flat();\n  return {\n    columns: columns,\n    headers: headers\n  };\n}\nfunction convertToInternalHeaders(items) {\n  var internalHeaders = [];\n  var _iterator6 = _createForOfIteratorHelper(items),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _defaultItem$key, _ref, _defaultItem$value, _defaultItem$sortable;\n      var item = _step6.value;\n      var defaultItem = _objectSpread(_objectSpread({}, getDefaultItem(item)), item);\n      var key = (_defaultItem$key = defaultItem.key) !== null && _defaultItem$key !== void 0 ? _defaultItem$key : typeof defaultItem.value === 'string' ? defaultItem.value : null;\n      var value = (_ref = (_defaultItem$value = defaultItem.value) !== null && _defaultItem$value !== void 0 ? _defaultItem$value : key) !== null && _ref !== void 0 ? _ref : null;\n      var internalItem = _objectSpread(_objectSpread({}, defaultItem), {}, {\n        key: key,\n        value: value,\n        sortable: (_defaultItem$sortable = defaultItem.sortable) !== null && _defaultItem$sortable !== void 0 ? _defaultItem$sortable : defaultItem.key != null || !!defaultItem.sort,\n        children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : undefined\n      });\n      internalHeaders.push(internalItem);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return internalHeaders;\n}\nexport function createHeaders(props, options) {\n  var headers = ref([]);\n  var columns = ref([]);\n  var sortFunctions = ref({});\n  var sortRawFunctions = ref({});\n  var filterFunctions = ref({});\n  watchEffect(function () {\n    var _props$items$, _options$groupBy, _options$showSelect, _options$showExpand;\n    var _headers = props.headers || Object.keys((_props$items$ = props.items[0]) !== null && _props$items$ !== void 0 ? _props$items$ : {}).map(function (key) {\n      return {\n        key: key,\n        title: capitalize(key)\n      };\n    });\n    var items = _headers.slice();\n    var keys = extractKeys(items);\n    if (options !== null && options !== void 0 && (_options$groupBy = options.groupBy) !== null && _options$groupBy !== void 0 && _options$groupBy.value.length && !keys.has('data-table-group')) {\n      items.unshift({\n        key: 'data-table-group',\n        title: 'Group'\n      });\n    }\n    if (options !== null && options !== void 0 && (_options$showSelect = options.showSelect) !== null && _options$showSelect !== void 0 && _options$showSelect.value && !keys.has('data-table-select')) {\n      items.unshift({\n        key: 'data-table-select'\n      });\n    }\n    if (options !== null && options !== void 0 && (_options$showExpand = options.showExpand) !== null && _options$showExpand !== void 0 && _options$showExpand.value && !keys.has('data-table-expand')) {\n      items.push({\n        key: 'data-table-expand'\n      });\n    }\n    var internalHeaders = convertToInternalHeaders(items);\n    parseFixedColumns(internalHeaders);\n    var maxDepth = Math.max.apply(Math, _toConsumableArray(internalHeaders.map(function (item) {\n      return getDepth(item);\n    }))) + 1;\n    var parsed = parse(internalHeaders, maxDepth);\n    headers.value = parsed.headers;\n    columns.value = parsed.columns;\n    var flatHeaders = parsed.headers.flat(1);\n    var _iterator7 = _createForOfIteratorHelper(flatHeaders),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var header = _step7.value;\n        if (!header.key) continue;\n        if (header.sortable) {\n          if (header.sort) {\n            sortFunctions.value[header.key] = header.sort;\n          }\n          if (header.sortRaw) {\n            sortRawFunctions.value[header.key] = header.sortRaw;\n          }\n        }\n        if (header.filter) {\n          filterFunctions.value[header.key] = header.filter;\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n  });\n  var data = {\n    headers: headers,\n    columns: columns,\n    sortFunctions: sortFunctions,\n    sortRawFunctions: sortRawFunctions,\n    filterFunctions: filterFunctions\n  };\n  provide(VDataTableHeadersSymbol, data);\n  return data;\n}\nexport function useHeaders() {\n  var data = inject(VDataTableHeadersSymbol);\n  if (!data) throw new Error('Missing headers!');\n  return data;\n}","map":{"version":3,"names":["capitalize","inject","provide","ref","watchEffect","consoleError","propsFactory","makeDataTableHeaderProps","headers","Array","VDataTableHeadersSymbol","Symbol","defaultHeader","title","sortable","defaultActionHeader","_objectSpread","width","priorityQueue","arr","arguments","length","undefined","queue","map","element","priority","enqueue","added","i","item","splice","push","size","count","whole","Math","floor","dequeue","shift","extractLeaves","columns","children","_iterator","_createForOfIteratorHelper","_step","s","n","done","child","value","err","e","f","extractKeys","keys","Set","_iterator2","_step2","key","add","getDefaultItem","includes","getDepth","depth","max","apply","concat","_toConsumableArray","parseFixedColumns","items","seenFixed","setFixed","parentFixed","fixed","lastFixed","isNaN","setFixedOffset","fixedOffset","_iterator3","_step3","parseFloat","_iterator4","_step4","parse","maxDepth","currentDepth","rowSize","row","fraction","_queue$dequeue","diff","rowspan","colspan","_iterator5","_step5","sort","pow","flat","convertToInternalHeaders","internalHeaders","_iterator6","_step6","_defaultItem$key","_ref","_defaultItem$value","_defaultItem$sortable","defaultItem","internalItem","createHeaders","props","options","sortFunctions","sortRawFunctions","filterFunctions","_props$items$","_options$groupBy","_options$showSelect","_options$showExpand","_headers","Object","slice","groupBy","has","unshift","showSelect","showExpand","parsed","flatHeaders","_iterator7","_step7","header","sortRaw","filter","data","useHeaders","Error"],"sources":["../../../../src/components/VDataTable/composables/headers.ts"],"sourcesContent":["// Utilities\nimport { capitalize, inject, provide, ref, watchEffect } from 'vue'\nimport { consoleError, propsFactory } from '@/util'\n\n// Types\nimport type { DeepReadonly, InjectionKey, PropType, Ref } from 'vue'\nimport type { SortItem } from './sort'\nimport type { DataTableCompareFunction, DataTableHeader, InternalDataTableHeader } from '../types'\nimport type { FilterKeyFunctions } from '@/composables/filter'\n\nexport const makeDataTableHeaderProps = propsFactory({\n  headers: Array as PropType<DeepReadonly<DataTableHeader[]>>,\n}, 'DataTable-header')\n\nexport const VDataTableHeadersSymbol: InjectionKey<{\n  headers: Ref<InternalDataTableHeader[][]>\n  columns: Ref<InternalDataTableHeader[]>\n}> = Symbol.for('vuetify:data-table-headers')\n\ntype HeaderProps = {\n  headers: DeepReadonly<DataTableHeader[]> | undefined\n  items: any[]\n}\n\nconst defaultHeader = { title: '', sortable: false }\nconst defaultActionHeader = { ...defaultHeader, width: 48 }\n\nfunction priorityQueue <T> (arr: T[] = []) {\n  const queue: { element: T, priority: number }[] = arr.map(element => ({ element, priority: 0 }))\n\n  return {\n    enqueue: (element: T, priority: number) => {\n      let added = false\n      for (let i = 0; i < queue.length; i++) {\n        const item = queue[i]\n        if (item.priority > priority) {\n          queue.splice(i, 0, { element, priority })\n          added = true\n          break\n        }\n      }\n\n      if (!added) queue.push({ element, priority })\n    },\n    size: () => queue.length,\n    count: () => {\n      let count = 0\n\n      if (!queue.length) return 0\n\n      const whole = Math.floor(queue[0].priority)\n      for (let i = 0; i < queue.length; i++) {\n        if (Math.floor(queue[i].priority) === whole) count += 1\n      }\n\n      return count\n    },\n    dequeue: () => {\n      return queue.shift()\n    },\n  }\n}\n\nfunction extractLeaves (item: InternalDataTableHeader, columns: InternalDataTableHeader[] = []) {\n  if (!item.children) {\n    columns.push(item)\n  } else {\n    for (const child of item.children) {\n      extractLeaves(child, columns)\n    }\n  }\n\n  return columns\n}\n\nfunction extractKeys (headers: DeepReadonly<DataTableHeader[]>, keys = new Set<string>()) {\n  for (const item of headers) {\n    if (item.key) keys.add(item.key)\n\n    if (item.children) {\n      extractKeys(item.children, keys)\n    }\n  }\n\n  return keys\n}\n\nfunction getDefaultItem (item: DeepReadonly<DataTableHeader>) {\n  if (!item.key) return undefined\n  if (item.key === 'data-table-group') return defaultHeader\n  if (['data-table-expand', 'data-table-select'].includes(item.key)) return defaultActionHeader\n  return undefined\n}\n\nfunction getDepth (item: InternalDataTableHeader, depth = 0): number {\n  if (!item.children) return depth\n\n  return Math.max(depth, ...item.children.map(child => getDepth(child, depth + 1)))\n}\n\nfunction parseFixedColumns (items: InternalDataTableHeader[]) {\n  let seenFixed = false\n  function setFixed (item: InternalDataTableHeader, parentFixed = false) {\n    if (!item) return\n\n    if (parentFixed) {\n      item.fixed = true\n    }\n\n    if (item.fixed) {\n      if (item.children) {\n        for (let i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i], true)\n        }\n      } else {\n        if (!seenFixed) {\n          item.lastFixed = true\n        } else if (isNaN(+item.width!)) {\n          consoleError(`Multiple fixed columns should have a static width (key: ${item.key})`)\n        }\n        seenFixed = true\n      }\n    } else {\n      if (item.children) {\n        for (let i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i])\n        }\n      } else {\n        seenFixed = false\n      }\n    }\n  }\n\n  for (let i = items.length - 1; i >= 0; i--) {\n    setFixed(items[i])\n  }\n\n  function setFixedOffset (item: InternalDataTableHeader, fixedOffset = 0) {\n    if (!item) return fixedOffset\n\n    if (item.children) {\n      item.fixedOffset = fixedOffset\n      for (const child of item.children) {\n        fixedOffset = setFixedOffset(child, fixedOffset)\n      }\n    } else if (item.fixed) {\n      item.fixedOffset = fixedOffset\n      fixedOffset += parseFloat(item.width || '0') || 0\n    }\n\n    return fixedOffset\n  }\n\n  let fixedOffset = 0\n  for (const item of items) {\n    fixedOffset = setFixedOffset(item, fixedOffset)\n  }\n}\n\nfunction parse (items: InternalDataTableHeader[], maxDepth: number) {\n  const headers: InternalDataTableHeader[][] = []\n  let currentDepth = 0\n  const queue = priorityQueue(items)\n\n  while (queue.size() > 0) {\n    let rowSize = queue.count()\n    const row: InternalDataTableHeader[] = []\n    let fraction = 1\n    while (rowSize > 0) {\n      const { element: item, priority } = queue.dequeue()!\n      const diff = maxDepth - currentDepth - getDepth(item)\n\n      row.push({\n        ...item,\n        rowspan: diff ?? 1,\n        colspan: item.children ? extractLeaves(item).length : 1,\n      })\n\n      if (item.children) {\n        for (const child of item.children) {\n          // This internally sorts items that are on the same priority \"row\"\n          const sort = priority % 1 + (fraction / Math.pow(10, currentDepth + 2))\n          queue.enqueue(child, currentDepth + diff + sort)\n        }\n      }\n\n      fraction += 1\n      rowSize -= 1\n    }\n    currentDepth += 1\n    headers.push(row)\n  }\n\n  const columns = items.map(item => extractLeaves(item)).flat()\n\n  return { columns, headers }\n}\n\nfunction convertToInternalHeaders (items: DeepReadonly<DataTableHeader[]>) {\n  const internalHeaders: InternalDataTableHeader[] = []\n  for (const item of items) {\n    const defaultItem = { ...getDefaultItem(item), ...item }\n    const key = defaultItem.key ?? (typeof defaultItem.value === 'string' ? defaultItem.value : null)\n    const value = defaultItem.value ?? key ?? null\n    const internalItem: InternalDataTableHeader = {\n      ...defaultItem,\n      key,\n      value,\n      sortable: defaultItem.sortable ?? (defaultItem.key != null || !!defaultItem.sort),\n      children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : undefined,\n    }\n\n    internalHeaders.push(internalItem)\n  }\n\n  return internalHeaders\n}\n\nexport function createHeaders (\n  props: HeaderProps,\n  options?: {\n    groupBy?: Ref<readonly SortItem[]>\n    showSelect?: Ref<boolean>\n    showExpand?: Ref<boolean>\n  }\n) {\n  const headers = ref<InternalDataTableHeader[][]>([])\n  const columns = ref<InternalDataTableHeader[]>([])\n  const sortFunctions = ref<Record<string, DataTableCompareFunction>>({})\n  const sortRawFunctions = ref<Record<string, DataTableCompareFunction>>({})\n  const filterFunctions = ref<FilterKeyFunctions>({})\n\n  watchEffect(() => {\n    const _headers = props.headers ||\n      Object.keys(props.items[0] ?? {}).map(key => ({ key, title: capitalize(key) })) as never\n\n    const items = _headers.slice()\n    const keys = extractKeys(items)\n\n    if (options?.groupBy?.value.length && !keys.has('data-table-group')) {\n      items.unshift({ key: 'data-table-group', title: 'Group' })\n    }\n\n    if (options?.showSelect?.value && !keys.has('data-table-select')) {\n      items.unshift({ key: 'data-table-select' })\n    }\n\n    if (options?.showExpand?.value && !keys.has('data-table-expand')) {\n      items.push({ key: 'data-table-expand' })\n    }\n\n    const internalHeaders = convertToInternalHeaders(items)\n\n    parseFixedColumns(internalHeaders)\n\n    const maxDepth = Math.max(...internalHeaders.map(item => getDepth(item))) + 1\n    const parsed = parse(internalHeaders, maxDepth)\n\n    headers.value = parsed.headers\n    columns.value = parsed.columns\n\n    const flatHeaders = parsed.headers.flat(1)\n\n    for (const header of flatHeaders) {\n      if (!header.key) continue\n\n      if (header.sortable) {\n        if (header.sort) {\n          sortFunctions.value[header.key] = header.sort\n        }\n\n        if (header.sortRaw) {\n          sortRawFunctions.value[header.key] = header.sortRaw\n        }\n      }\n\n      if (header.filter) {\n        filterFunctions.value[header.key] = header.filter\n      }\n    }\n  })\n\n  const data = { headers, columns, sortFunctions, sortRawFunctions, filterFunctions }\n\n  provide(VDataTableHeadersSymbol, data)\n\n  return data\n}\n\nexport function useHeaders () {\n  const data = inject(VDataTableHeadersSymbol)\n\n  if (!data) throw new Error('Missing headers!')\n\n  return data\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}