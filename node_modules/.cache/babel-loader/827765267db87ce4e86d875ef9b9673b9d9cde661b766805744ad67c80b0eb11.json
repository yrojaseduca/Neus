{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\n// Utilities\nimport { computed, onBeforeUnmount, onMounted, ref, shallowRef, watch } from 'vue';\nimport { clamp, consoleWarn, propsFactory } from \"../util/index.mjs\"; // Types\n// Composables\nexport var makeScrollProps = propsFactory({\n  scrollTarget: {\n    type: String\n  },\n  scrollThreshold: {\n    type: [String, Number],\n    \"default\": 300\n  }\n}, 'scroll');\nexport function useScroll(props) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var canScroll = args.canScroll;\n  var previousScroll = 0;\n  var target = ref(null);\n  var currentScroll = shallowRef(0);\n  var savedScroll = shallowRef(0);\n  var currentThreshold = shallowRef(0);\n  var isScrollActive = shallowRef(false);\n  var isScrollingUp = shallowRef(false);\n  var scrollThreshold = computed(function () {\n    return Number(props.scrollThreshold);\n  });\n\n  /**\n   * 1: at top\n   * 0: at threshold\n   */\n  var scrollRatio = computed(function () {\n    return clamp((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);\n  });\n  var onScroll = function onScroll() {\n    var targetEl = target.value;\n    if (!targetEl || canScroll && !canScroll.value) return;\n    previousScroll = currentScroll.value;\n    currentScroll.value = 'window' in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;\n    isScrollingUp.value = currentScroll.value < previousScroll;\n    currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);\n  };\n  watch(isScrollingUp, function () {\n    savedScroll.value = savedScroll.value || currentScroll.value;\n  });\n  watch(isScrollActive, function () {\n    savedScroll.value = 0;\n  });\n  onMounted(function () {\n    watch(function () {\n      return props.scrollTarget;\n    }, function (scrollTarget) {\n      var _target$value;\n      var newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;\n      if (!newTarget) {\n        consoleWarn(\"Unable to locate element with identifier \".concat(scrollTarget));\n        return;\n      }\n      if (newTarget === target.value) return;\n      (_target$value = target.value) === null || _target$value === void 0 || _target$value.removeEventListener('scroll', onScroll);\n      target.value = newTarget;\n      target.value.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    }, {\n      immediate: true\n    });\n  });\n  onBeforeUnmount(function () {\n    var _target$value2;\n    (_target$value2 = target.value) === null || _target$value2 === void 0 || _target$value2.removeEventListener('scroll', onScroll);\n  });\n\n  // Do we need this? If yes - seems that\n  // there's no need to expose onScroll\n  canScroll && watch(canScroll, onScroll, {\n    immediate: true\n  });\n  return {\n    scrollThreshold: scrollThreshold,\n    currentScroll: currentScroll,\n    currentThreshold: currentThreshold,\n    isScrollActive: isScrollActive,\n    scrollRatio: scrollRatio,\n    // required only for testing\n    // probably can be removed\n    // later (2 chars chlng)\n    isScrollingUp: isScrollingUp,\n    savedScroll: savedScroll\n  };\n}","map":{"version":3,"names":["computed","onBeforeUnmount","onMounted","ref","shallowRef","watch","clamp","consoleWarn","propsFactory","makeScrollProps","scrollTarget","type","String","scrollThreshold","Number","useScroll","props","args","arguments","length","undefined","canScroll","previousScroll","target","currentScroll","savedScroll","currentThreshold","isScrollActive","isScrollingUp","scrollRatio","value","onScroll","targetEl","pageYOffset","scrollTop","Math","abs","_target$value","newTarget","document","querySelector","window","concat","removeEventListener","addEventListener","passive","immediate","_target$value2"],"sources":["../../src/composables/scroll.ts"],"sourcesContent":["// Utilities\nimport {\n  computed,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { clamp, consoleWarn, propsFactory } from '@/util'\n\n// Types\nimport type { Ref } from 'vue'\n\nexport interface ScrollProps {\n  scrollTarget?: string\n  scrollThreshold?: string | number\n}\n\nexport interface ThresholdMetCallbackData {\n  isScrollingUp: boolean\n  currentThreshold: number\n  savedScroll: Ref<number>\n}\n\n// Composables\nexport const makeScrollProps = propsFactory({\n  scrollTarget: {\n    type: String,\n  },\n  scrollThreshold: {\n    type: [String, Number],\n    default: 300,\n  },\n}, 'scroll')\n\nexport interface ScrollArguments {\n  canScroll?: Readonly<Ref<boolean>>\n}\n\nexport function useScroll (\n  props: ScrollProps,\n  args: ScrollArguments = {},\n) {\n  const { canScroll } = args\n  let previousScroll = 0\n  const target = ref<Element | Window | null>(null)\n  const currentScroll = shallowRef(0)\n  const savedScroll = shallowRef(0)\n  const currentThreshold = shallowRef(0)\n  const isScrollActive = shallowRef(false)\n  const isScrollingUp = shallowRef(false)\n\n  const scrollThreshold = computed(() => {\n    return Number(props.scrollThreshold)\n  })\n\n  /**\n   * 1: at top\n   * 0: at threshold\n   */\n  const scrollRatio = computed(() => {\n    return clamp(((scrollThreshold.value - currentScroll.value) / scrollThreshold.value) || 0)\n  })\n\n  const onScroll = () => {\n    const targetEl = target.value\n\n    if (!targetEl || (canScroll && !canScroll.value)) return\n\n    previousScroll = currentScroll.value\n    currentScroll.value = ('window' in targetEl) ? targetEl.pageYOffset : targetEl.scrollTop\n\n    isScrollingUp.value = currentScroll.value < previousScroll\n    currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value)\n  }\n\n  watch(isScrollingUp, () => {\n    savedScroll.value = savedScroll.value || currentScroll.value\n  })\n\n  watch(isScrollActive, () => {\n    savedScroll.value = 0\n  })\n\n  onMounted(() => {\n    watch(() => props.scrollTarget, scrollTarget => {\n      const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window\n\n      if (!newTarget) {\n        consoleWarn(`Unable to locate element with identifier ${scrollTarget}`)\n        return\n      }\n\n      if (newTarget === target.value) return\n\n      target.value?.removeEventListener('scroll', onScroll)\n      target.value = newTarget\n      target.value.addEventListener('scroll', onScroll, { passive: true })\n    }, { immediate: true })\n  })\n\n  onBeforeUnmount(() => {\n    target.value?.removeEventListener('scroll', onScroll)\n  })\n\n  // Do we need this? If yes - seems that\n  // there's no need to expose onScroll\n  canScroll && watch(canScroll, onScroll, { immediate: true })\n\n  return {\n    scrollThreshold,\n    currentScroll,\n    currentThreshold,\n    isScrollActive,\n    scrollRatio,\n\n    // required only for testing\n    // probably can be removed\n    // later (2 chars chlng)\n    isScrollingUp,\n    savedScroll,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}